# Software Development Chapter 2 (Java)

## 1. 안티 패턴 그리고 단일 책임 원칙   
### 1-1. 안티 패턴 *anti-patterns*
```
  < 들어가기 전에 - 코드가 가져야 하는 속성 >
- 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야 한다.
- 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야 한다.
- 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야 한다.
- 캡슐화가 잘 되어 있어야 한다.
```
+ **안티 패턴 1 - 갓 클래스** *god class*   
한 개의 파일에 모든 코드를 구현하다 보면 결국 하나의 거대한 클래스가 탄생하면서 클래스의 목적이 무엇인지 이해하기 어려워 진다.
하나의 거대한 클래스가 모든 일을 수행하기 때문이다.
만약 기존 코드의 로직을 갱신해야 한다면, 거대한 클래스 안에서 해당 코드를 찾아 바꾸는 것은 매우 힘든 작업이 될 가능성이 높다.
이런 문제를 갓 클래스 안티 패턴이라 부른다. 이렇게 **한 클래스로 모든 것을 해결하는 패턴이 나타나지 않도록 주의**해야 한다.

+ **안티 패턴 2 - 코드 중복** *code duplication*   
예를 들어 한 가지 파일 형식의 문제만 해결하는 로직들이 중복된 경우, 파일 입력 형식이 바뀌거나 다양한 형식의 파일을 지원해야 한다면 모든 곳의 코드를 바꿔야 하며, 새로운 버그가 발생할 가능성 또한 커진다.
코드를 간결하게 유지하는 것도 중요하지만, KISS *(keep it short and simple)* 원칙을 남용하여 위와 같은 문제가 발생하지 않도록 주의해야 한다.
따라서 **전체적인 응용프로그램의 설계를 되돌아보고, 한 문제를 작은 개별 문제로 분리해 더 쉽게 관리할 수 있는지 파악하는 것이 필요**하다.

```
(+) DRY 중복 배제 원칙 (Don’t Repeat Yourself) : 반복을 제거하면 로직을 바꿔도 여러 곳의 코드를 바꿔야 할 필요성이 없어진다.
```

### 1-2. 단일 책임 원칙 *Single-Responsibility Principle*
단일 책임 원칙은 쉽게 관리하고 유지보수 할 수 있는 코드를 구현하는데 도움을 주는 포괄적인 소프트트웨어 개발 지침이다.
```
- 하나의 클래스는 하나의 기능만 책임진다.
- 클래스가 바뀌어야 하는 이유는 오직 하나여야 한다.
```
SRP는 일반적으로 클래스와 메서드에 적용하며 한 가지 특정 동작, 개념 또는 카테고리와 관련된다.
SRP를 적용하면 코드가 바뀌어야 하는 이유가 한 가지로 제한되므로 더 튼튼한 코드를 만들 수 있다.

메서드를 구현할 때는 놀람 최소화 원칙을 따라야 한다.
코드를 보고 무슨 일이 일어나는지 명확히 이해할 수 있다.
```
- 메서드가 수행하는 일을 바로 이해할 수 있도록 자체 문서화를 제공하는 메서드명을 사용한다.
- 코드의 다른 부분이 파라미터의 상태에 의존할 수 있으므로 파라미터의 상태를 바꾸지 않는다.
```
## 2. 응집도와 결합도
### 2-1. 응집도 *cohesion*
응집도는 서로 어떻게 관련되어 있는지를 가리킨다. 정확히 말하자면 **응집도는 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 측정**한다.
높은 응집도는 누구나 쉽게 코드를 찾고, 이해하고, 사용할 수 있도록 만들고 싶어 한다.

실무에서는 일반적으로 다음과 같은 여섯 가지 방법으로 그룹화한다.   
   
- **기능** : 클래스를 구현할 때 기능이 비슷한 메서드를 그룹화
  - 장점 : 함께 사용하는 메서드를 그룹화하면 찾기도 쉽고 이해하기도 쉬우므로 응집도를 높인다.
  - 주의할 점 : 기능 응집은 한 개의 메서드를 갖는 클래스를 너무 과도하게 만들려는 경향이 발생할 수 있다.
  간단한 클래스를 과도하게 만들면 그만큼 생각해야 할 클래스가 많아지므로 코드가 장황해지고 복잡해진다.

- **정보** : 같은 데이터나 도메인 객체를 처리하는 메서드를 그룹화
  - 장점 : 유지보수가 쉽다.
  - 주의할 점 : 여러 기능을 그룹화하면서, 필요한 일부 기능을 포함하는 클래스 전체를 디펜던서dependency로 추가한다는 약점이 있다.

- **유틸리티** : 관련성이 없는 메서드를 한 클래스에 포함
  - 사용 이유 : 메서드가 어디에 속해야 할지 결정하기 어려울 때 사용한다.
  - 장점 : 간단히 추가하는 것이 가능하다.
  - 주의할 점 : 유틸리티 클래스 사용은 낮은 응집도로 이어진다. 메서드가 서로 연관성이 없으므로 클래스 전체의 기능을 추론하기가 어렵기 때문에,
  더욱이 코드를 쉽게 찾고, 어떻게 사용할 수 있는지 이해하기 쉽도록 만들어야 한다.

- **논리** : 예) '파싱'이라는 논리로 CSV, JSON, XML의 자료를 파싱하는 코드를 한 클래스로 그룹화
  - 주의할 점: 본질적으로 다르며 관련이 없는 메서드를 그룹화하게 되면 클래스는 여러 개의 책임을 갖게 되므로 SRP를 위배한다. 이 방법은 권장하지 않는다.

- **순차** : 파일을 읽고, 파싱하고, 처리하고, 정보를 저장하는 메서드들을 한 클래스로 그룹화
  - 장점 : 순차 응집은 여러 동작이 어떻게 함께 수행되는지 쉽게 이해할 수 있다.
  - 주의할 점 : 실전에서 순차 응집을 적용하면 한 클래스를 바꿔야 할 여러 이유가 존재하므로 SRP를 위배한다.
  더욱이 데이터를 처리, 요약, 저장하는 방법이 다양하므로 결국 이 기법은 클래스를 순식간에 복잡하게 만든다.

- **시간** : 여러 연산 중 시간과 관련된 연산을 그룹화
  - 주의할 점 : 각 동작을 이해하고 사용하는 것이 어렵다.   
   
### 2-2. 결합도 *cohesion*
결합도는 코드가 서로 어떻게 의존하는지와 관련된 척도를 가리킨다.
결합도는 **어떤 클래스를 구현하는 데 얼마나 많은 다른 클래스를 참조했는가**로 설명할 수 있다.
많은 클래스를 참조할수록 기능을 변경할 때 그만큼 유연성이 떨어진다. 한 클래스의 코드를 바꾸면 해당 클래스에 의존하는 모든 클래스가 영향을 받는다.
따라서 보통 코드를 구현할 때는 **결합도를 낮춰야 한다.** 이는 코드의 다양한 컴포넌트가 내부와 세부 구현에 의존하지 않아야 함을 의미하며, 높은 결합도는 무조건 피하는 것이 좋다.
   
## 3. 테스트
### 3-1. 테스트 자동화
소프트웨어 테스트를 수동 테스트에만 의존하면 안 된다.
**자동화된 테스트에서는 사람의 조작 없이 여러 테스트가 포함된 스위트가 자동으로 실행**된다. 즉 코드를 바꿨을 때, 지정된 테스트가 빠르게 실행되므로 소프트웨어가 예상하지 못한 문제를 일으키지 않고 제대로 동작할 거라는 확신을 조금 더 가질 수 있다.

  - **장점**
    - 확신 : 소프트웨어가 규격 사양과 일치하며 동작하는지를 테스트해 고객의 요구 사항을 충족하고 있다는 사실을 확신할 수 있다. 테스트 규격 사양과 결과를 고객에게 증거로 제공할 수도 있다.
    - 변화에도 튼튼함을 유지 : 자동화된 테스트 스위트가 있다면 바꾼 코드로 인해 새로운 버그가 발생하지 않았음을 확인하는 데 큰 도움이 된다.
    - 프로그램 이해도에 도움 : 테스트 자동화는 소스코드의 프로젝트에서 다양한 컴포넌트가 어떻게 동작하는지 이해하는 데 도움을 준다.
    테스트는 다양한 컴포넌트의 디펜던시와 이들이 어떻게 상호작용 하는지를 명확하게 드러낸다.
    따라서 소프트웨어의 전체 개요를 빨리 파악할 수 있다.

### 3-2. JUnit 사용하기
자바 프레임워크인 **JUnit**을 이용해 메서드나 클래스처럼 작고 고립된 단위를 테스트하는 유닛 테스트를 구현한다.
보통 테스트 클래스명에는 **Test**라는 접미어를 붙이는 것이 관습이다.

  - **Annotation**
    - **@Test**   
    해당 어노테이션이 붙은 메서드를 테스트 한다.   
    - **@Test(timeout = ms)**   
    ms 시간 안에 실행이 완료되면 성공, 실행이 완료되지 않으면 실패로 처리된다.   
    - **@Test(expected = Exception.class)**   
    해당 예외가 발생하면 성공, 예외가 발생하지 않으면 실패로 처리된다.   
    - **@Before @After**   
    각 테스트 전과 후에 실행되어야 하는 코드를 넣는다.   
    - **@BeforeClass @AfterClass**   
    모든 테스트 전과 후에 실행되어야 하는 코드를 넣는다.   
    - **@Ignore**   
    해당 테스트 케이스를 무시할 때 사용한다.   

  - **AssertJ**   
  메소드 체이닝을 지원하기 때문에 좀 더 깔끔하고 읽기 쉬운 테스트 코드를 작성할 수 있으며, 필요하다고 생각하는 대부분의 메소드를 제공한다.   

    - **AssertJ 메소드 임포트**   
    정적 임포트를 통해 AssertJ의 다양한 API를 클래스 이름없이 바로 사용할 수 있다.
    ```java
    import static org.assertj.core.api.Assertions.*;
    ```

    - **테스트 대상 지정하기**   
    모든 테스트 코드는 ```assertThat()``` 메소드에서 출발한다.
    AssertJ에서 제공하는 다양한 메소드를 연쇄 호출하면서 코드를 작성할 수 있다.
    ```java
    assertThat(테스트 타겟).메소드1().메소드2().메소드3();
    ```

    - 간단한 **문자열** 테스트    
    ```java
    assertThat("Hello, AssertJ. Nice to meet you!")
        .isnotEmpty()
        .contains("AssertJ")
        .contains("meet")
        .doseNotContain("love")
        .startsWith("He")
        .endsWith("!")
        .isEqualTo("Hello, AssertJ. Nice to meet you!")
    ```

    - 간단한 **숫자** 테스트    
    ```java
    assertThat(1.27d)
        .isPositive()
        .isGreaterThan(1)
        .isLessThan(2)
        .isEqualTo(1, offset(1d))
        .isEqualTo(1.2, offset(0.1d))
        .isEqualTo(1.27);
    ```

  - **Given-When-Then 패턴**   
  테스트가 무엇을 수행하는지 쉽게 이해하기 위해 테스트를 패턴에 따라 세 부분으로 분리하는 것이 좋다.
    - **Given**   
    테스트를 위해 준비를 하는 과정이다. 테스트에 사용하는 변수, 입력 값 등을 정의한다.
    - **When**    
    실제로 액션을 하는 테스트를 실행하는 과정이다.
    - **Then**   
    마지막은 테스트를 검증하는 과정이다. 예상한 값, 실제 실행을 통해서 나온 값을 검증한다.

### 3-3. 코드 커버리지
코드 커버리지*code coverage*는 테스트 집합이 **소프트웨어의 소스코드를 얼마나 테스트 했는가**를 가리키는 척도다.
커버리지가 높을수록 예상하지 못한 버그가 발생할 확률이 낮아지므로 되도록 커버리지를 높이는 것을 목표로 삼아야 한다. 일반적으로 70에서 90%를 목표로 정할 것을 권장한다.
   
단, 코드 커버리지가 높다고 해서 소프트웨어를 잘 테스트하고 있음을 의미하는 것은 아니다.
테스트하지 않은 부분이 남아 있음을 알려주는 역할에 지나지 않기 때문에 테스트의 품질과는 아무 관련이 없다.   
   
- **코드 커버리지 종류**   
  - **구문 커버리지** : 얼마나 많은 구문의 코드를 커버했는지를 의미하며, 분기문(if, while, for)의 가능한 여러 개의 경로를 파악하지 못하고 한 구문으로 취급한다는 약점이 있다.   
  - **분기 커버리지** : 각 분기문을 확인한다. 구문 커버리지보다 분기 커버리지를 사용하는 것을 권장한다.   
   
## 4. chapter 2 총정리
- 갓 클래스와 코드 중복은 코드를 추론하고 유지보수하기 어렵게 만든다.
- 단일 책임 원칙은 관리하고 유지보수하기 쉬운 코드를 구현하는 데 도움을 준다.
- 응집도는 클래스나 메서드의 책임이 얼마나 강하게 연관되어 있는지를 가리킨다.
- 결합도는 클래스가 다른 코드 부분에 얼마나 의존하고 있는지를 가리킨다.
- 높은 응집도와 낮은 결합도는 유지보수가 가능한 코드가 가져야 할 특징이다.
- 자동화된 테스트의 스위트는 소프트웨어가 올바르게 동작하고 코드를 수정해도 잘 동작할 것임을 확신할 수 있게 도와주며 프로그램을 쉽게 이해할 수 있도록 도움을 준다.
- 자바의 테스트 프레임워크인 제이유닛을 활용해 메서드와 클래스의 동작을 테스트 하는 유닛 테스트를 만든다.
- 테스트를 쉽게 이해할 수 있도록 Given-When-Then 패턴으로 유닛 테스트를 세 부분으로 분리하는 것이 좋다.

**출처** 위 내용은 [실전 자바 소프트웨어 개발](http://www.yes24.com/Product/Goods/90533758)와 [AssertJ 소개](https://www.daleseo.com/assertj/)를 정리한 문서이다.
